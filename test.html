
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>domain: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kenji-yamane/mgr8/domain/column_diff.go (33.3%)</option>
				
				<option value="file1">github.com/kenji-yamane/mgr8/domain/diff.go (100.0%)</option>
				
				<option value="file2">github.com/kenji-yamane/mgr8/domain/schema.go (100.0%)</option>
				
				<option value="file3">github.com/kenji-yamane/mgr8/domain/table_diff.go (33.3%)</option>
				
				<option value="file4">github.com/kenji-yamane/mgr8/drivers/mysql/deparser.go (0.0%)</option>
				
				<option value="file5">github.com/kenji-yamane/mgr8/drivers/mysql/parser.go (23.7%)</option>
				
				<option value="file6">github.com/kenji-yamane/mgr8/drivers/postgres/deparser.go (83.3%)</option>
				
				<option value="file7">github.com/kenji-yamane/mgr8/drivers/postgres/parser.go (21.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package domain

type CreateColumnDiff struct {
        tableName string
        columnName string
        column *Column
}

func NewCreateColumnDiff(tableName string, column *Column) *CreateColumnDiff <span class="cov8" title="1">{
        return &amp;CreateColumnDiff{tableName: tableName, column: column}
}</span>

func (d *CreateColumnDiff) Up(deparser Deparser) string<span class="cov0" title="0">{
        return deparser.AddColumn()
}</span>

func (d *CreateColumnDiff) Down(deparser Deparser) string<span class="cov0" title="0">{
        return deparser.DropColumn(d.tableName, d.columnName)
}</span>

type DropColumnDiff struct {
        tableName string
        columnName string
}

func NewDropColumnDiff(tableName string, columnName string) *DropColumnDiff <span class="cov8" title="1">{
        return &amp;DropColumnDiff{tableName: tableName, columnName: columnName}
}</span>

func (d *DropColumnDiff) Up(deparser Deparser) string<span class="cov0" title="0">{
        return deparser.DropColumn(d.tableName, d.columnName)
}</span>

func (d *DropColumnDiff) Down(deparser Deparser) string<span class="cov0" title="0">{
        return deparser.AddColumn()
}</span>

type MakeColumnNotNullDiff struct {
        tableName string
        columnName string
}

func NewMakeColumnNotNullDiff(tableName string, columnName string) *MakeColumnNotNullDiff <span class="cov8" title="1">{
        return &amp;MakeColumnNotNullDiff{tableName: tableName, columnName: columnName}
}</span>

func (m *MakeColumnNotNullDiff) Up(deparser Deparser) string <span class="cov0" title="0">{
        return deparser.MakeColumnNotNull(m.tableName, m.columnName)
}</span>

func (m *MakeColumnNotNullDiff) Down(deparser Deparser) string <span class="cov0" title="0">{
        return deparser.UnmakeColumnNotNull(m.tableName, m.columnName)
}</span>

type UnmakeColumnNotNullDiff struct {
        tableName string
        columnName string
}

func NewUnmakeColumnNotNullDiff(tableName string, columnName string) *UnmakeColumnNotNullDiff <span class="cov8" title="1">{
        return &amp;UnmakeColumnNotNullDiff{tableName: tableName, columnName: columnName}
}</span>

func (m *UnmakeColumnNotNullDiff) Up(deparser Deparser) string <span class="cov0" title="0">{
        return deparser.UnmakeColumnNotNull(m.tableName, m.columnName)
}</span>

func (m *UnmakeColumnNotNullDiff) Down(deparser Deparser) string <span class="cov0" title="0">{
        return deparser.MakeColumnNotNull(m.tableName, m.columnName)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package domain

type Diff interface{
        Up(driver Deparser) string
        Down(driver Deparser) string
}

func (s *Schema) Diff(originalSchema *Schema) []Diff <span class="cov8" title="1">{
        diffsQueue := []Diff{}

        for tableName, table := range s.Tables </span><span class="cov8" title="1">{
                originalTable, originalHasTable := originalSchema.Tables[tableName]
                if !originalHasTable </span><span class="cov8" title="1">{
                        diffsQueue = append(diffsQueue, NewCreateTableDiff(table))
                }</span> else<span class="cov8" title="1"> {
                        diffsQueue = append(diffsQueue, table.Diff(originalTable)...)
                }</span>
        }

        <span class="cov8" title="1">for tableName, table := range originalSchema.Tables </span><span class="cov8" title="1">{
                if _, ok := s.Tables[tableName]; !ok </span><span class="cov8" title="1">{
                        diffsQueue = append(diffsQueue, NewDropTableDiff(table))
                }</span>
        }

        <span class="cov8" title="1">return diffsQueue</span>
}

func (t *Table) Diff(originalTable *Table) []Diff <span class="cov8" title="1">{
        diffsQueue := []Diff{}

        for columnName, column := range t.Columns </span><span class="cov8" title="1">{
                originalColumn, originalHasColumn := originalTable.Columns[columnName]
                if !originalHasColumn </span><span class="cov8" title="1">{
                        diffsQueue = append(diffsQueue, NewCreateColumnDiff(t.Name, column))
                }</span> else<span class="cov8" title="1"> {
                        diffsQueue = append(diffsQueue, column.Diff(t, columnName, originalColumn)...)
                }</span>
        }

        <span class="cov8" title="1">for columnName := range originalTable.Columns </span><span class="cov8" title="1">{
                if _, ok := t.Columns[columnName]; !ok </span><span class="cov8" title="1">{
                        diffsQueue = append(diffsQueue, NewDropColumnDiff(t.Name, columnName))
                }</span>
        }

        <span class="cov8" title="1">return diffsQueue</span>
}

func (c *Column) Diff(table *Table, columnName string, originalColumn *Column) []Diff <span class="cov8" title="1">{
        diffsQueue := []Diff{}
        column := table.Columns[columnName]
        if column.IsNotNull != originalColumn.IsNotNull </span><span class="cov8" title="1">{
                if column.IsNotNull </span><span class="cov8" title="1">{
                        diffsQueue = append(diffsQueue, NewMakeColumnNotNullDiff(table.Name, columnName))
                }</span> else<span class="cov8" title="1"> {
                         diffsQueue = append(diffsQueue, NewUnmakeColumnNotNullDiff(table.Name, columnName))
                }</span>
        }
        <span class="cov8" title="1">return diffsQueue</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package domain

type Schema struct {
        Tables map[string]*Table
        Views  map[string]*View
}

type Table struct {
        Name string
        Columns map[string]*Column
}

func NewTable(name string, columns map[string]*Column) *Table <span class="cov8" title="1">{
        return &amp;Table{Name: name, Columns: columns}
}</span>

type Column struct {
        Datatype   string
        Parameters map[string]interface{}
        IsNotNull  bool
}

type View struct {
        SQL string
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

type CreateTableDiff struct {
        table *Table
}

func NewCreateTableDiff(table *Table) *CreateTableDiff <span class="cov8" title="1">{
        return &amp;CreateTableDiff{table: table}
}</span>

func (d *CreateTableDiff) Up(deparser Deparser) string<span class="cov0" title="0">{
        return deparser.CreateTable(d.table)
}</span>

func (d *CreateTableDiff) Down(deparser Deparser) string<span class="cov0" title="0">{
        return deparser.DropTable(d.table.Name)
}</span>

type DropTableDiff struct {
        table *Table
}

func NewDropTableDiff(table *Table) *DropTableDiff <span class="cov8" title="1">{
        return &amp;DropTableDiff{table: table}
}</span>

func (d *DropTableDiff) Up(deparser Deparser) string<span class="cov0" title="0">{
        return deparser.DropTable(d.table.Name)
}</span>

func (d *DropTableDiff) Down(deparser Deparser) string<span class="cov0" title="0">{
        return deparser.CreateTable(d.table)
}</span>

</pre>
		
		<pre class="file" id="file4" style="display: none">package mysql

import (
        "fmt"

        "github.com/kenji-yamane/mgr8/domain"
)

type deparser struct { }

func (d *deparser) CreateTable(table *domain.Table) string <span class="cov0" title="0">{
        // TODO: how to mount this string?
        return ""
}</span>

func (d *deparser) DropTable(tableName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("DROP TABLE IF EXISTS %s", tableName)
}</span>

func (d *deparser) AddColumn() string <span class="cov0" title="0">{
        // TODO
        return ""
}</span>

func (d *deparser) DropColumn(tableName, columnName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("ALTER TABLE %s DROP COLUMN %s", tableName, columnName)
}</span>
func (d *deparser) MakeColumnNotNull(tableName, columnName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("ALTER TABLE %s ALTER COLUMN %s SET NOT NULL", tableName, columnName)
}</span>

func (d *deparser) UnmakeColumnNotNull(tableName, columnName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("ALTER TABLE %s ALTER COLUMN %s DROP NOT NULL", tableName, columnName)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package mysql

import (
        "database/sql"
        "errors"
        "log"

        "github.com/pingcap/parser/mysql"
        "github.com/pingcap/parser/types"

        _ "github.com/go-sql-driver/mysql"
        "github.com/jmoiron/sqlx"
        "github.com/pingcap/parser"
        "github.com/pingcap/parser/ast"
        _ "github.com/pingcap/tidb/types/parser_driver"

        "github.com/kenji-yamane/mgr8/domain"
)

type mySqlDriver struct {
        tx *sql.Tx
}

func NewMySqlDriver() *mySqlDriver <span class="cov8" title="1">{
        return &amp;mySqlDriver{}
}</span>

func (d *mySqlDriver) Deparser() domain.Deparser <span class="cov0" title="0">{
        return &amp;deparser{}
}</span>

func (d *mySqlDriver) Execute(statements []string) error <span class="cov0" title="0">{
        for _, stmt := range statements </span><span class="cov0" title="0">{
                _, err := d.tx.Exec(stmt)
                if err != nil </span><span class="cov0" title="0">{
                        err2 := d.tx.Rollback()
                        if err2 != nil </span><span class="cov0" title="0">{
                                return err2
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (d *mySqlDriver) ExecuteTransaction(url string, f func() error) error <span class="cov0" title="0">{
        db, err := sqlx.Connect("mysql", url)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>

        <span class="cov0" title="0">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.tx = tx

        err = f()
        if err != nil </span><span class="cov0" title="0">{
                err2 := d.tx.Rollback()
                if err2 != nil </span><span class="cov0" title="0">{
                        return err2
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return d.tx.Commit()</span>
}

func (d *mySqlDriver) IsToolInstalled() (bool, error) <span class="cov0" title="0">{
        hasMigrationLogsTable, err := d.HasMigrationLogsTable()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">hasAppliedMigrationsTable, err := d.HasAppliedMigrationsTable()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if hasAppliedMigrationsTable != hasMigrationLogsTable </span><span class="cov0" title="0">{ // Has just one of them (XOR)
                return false, errors.New("database in dirty state, tool is partially installed")
        }</span>
        <span class="cov0" title="0">return hasAppliedMigrationsTable &amp;&amp; hasMigrationLogsTable, err</span>
}

func (d *mySqlDriver) InstallTool() error <span class="cov0" title="0">{
        err := d.CreateMigrationsLogsTable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.CreateAppliedMigrationsTable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *mySqlDriver) UninstallTool() error <span class="cov0" title="0">{
        err := d.DropMigrationsLogsTable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.DropAppliedMigrationsTable()
        return err</span>
}

func (d *mySqlDriver) HasMigrationLogsTable() (bool, error) <span class="cov0" title="0">{
        var hasMigrationLogsTable bool
        err := d.tx.QueryRow(`SELECT EXISTS (
           SELECT FROM information_schema.tables
           WHERE  table_name   = $1
           )`, domain.LogsTableName).Scan(&amp;hasMigrationLogsTable)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return hasMigrationLogsTable, err</span>
}

func (d *mySqlDriver) HasAppliedMigrationsTable() (bool, error) <span class="cov0" title="0">{
        var hasAppliedMigrationsTable bool
        err := d.tx.QueryRow(`SELECT EXISTS (
           SELECT FROM information_schema.tables
           WHERE  table_name   = $1
           )`, domain.AppliedTableName).Scan(&amp;hasAppliedMigrationsTable)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return hasAppliedMigrationsTable, err</span>
}

func (d *mySqlDriver) CreateMigrationsLogsTable() error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`CREATE TABLE migration_log (
                migration_number INTEGER,
                type VARCHAR(4),
                username VARCHAR(32),
                date VARCHAR(32)
                )`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *mySqlDriver) CreateAppliedMigrationsTable() error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`CREATE TABLE applied_migrations (
                version INTEGER,
                username VARCHAR(32),
                date VARCHAR(32),
                hash VARCHAR(32)
                )`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *mySqlDriver) DropMigrationsLogsTable() error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`DROP TABLE migration_log`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *mySqlDriver) DropAppliedMigrationsTable() error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`DROP TABLE applied_migrations`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *mySqlDriver) InsertIntoMigrationLog(migrationNum int, migrationType string, username string, currentDate string) error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`INSERT INTO migration_log (
                migration_number,
                type,
                username,
                date
                ) VALUES ($1, $2, $3, $4)`, migrationNum, migrationType, username, currentDate)
        return err
}</span>

func (d *mySqlDriver) InsertIntoAppliedMigrations(version int, username string, currentDate string, hash string) error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`INSERT INTO applied_migrations (
                version,
                username,
                date,
                hash
                ) VALUES ($1, $2, $3, $4)`, version, username, currentDate, hash)
        return err
}</span>

func (d *mySqlDriver) RemoveAppliedMigration(version int) error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`DELETE FROM applied_migrations WHERE version = $1`, version)
        return err
}</span>

func (d *mySqlDriver) GetLatestMigrationVersion() (int, error) <span class="cov0" title="0">{
        var version int
        err := d.tx.QueryRow(`SELECT version FROM applied_migrations ORDER BY version DESC LIMIT 1`).Scan(&amp;version)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">return version, nil</span>
}

func (d *mySqlDriver) GetVersionHashing(version int) (string, error) <span class="cov0" title="0">{
        var hash string
        err := d.tx.QueryRow(`SELECT hash FROM applied_migrations WHERE version = $1 LIMIT 1`, version).Scan(&amp;hash)
        if err != nil </span><span class="cov0" title="0">{
                return ``, err
        }</span>
        <span class="cov0" title="0">return hash, nil</span>
}

type Visitor interface {
        Enter(n ast.Node) (node ast.Node, skipChildren bool)
        Leave(n ast.Node) (node ast.Node, ok bool)
}

type extractor struct {
        tables map[string]*domain.Table
        views  map[string]*domain.View
}

func (x *extractor) Enter(in ast.Node) (ast.Node, bool) <span class="cov8" title="1">{
        switch in.(type) </span>{
        case *ast.CreateTableStmt:<span class="cov8" title="1">
                createStmt := in.(*ast.CreateTableStmt)
                x.tables[createStmt.Table.Name.O] = x.parseTable(createStmt.Table.Name.O, createStmt)</span>
        case *ast.CreateViewStmt:<span class="cov8" title="1">
                createStmt := in.(*ast.CreateViewStmt)
                x.views[createStmt.ViewName.Name.O] = x.parseView(createStmt)</span>
        }
        <span class="cov8" title="1">return in, false</span>
}

func (x *extractor) parseTable(tableName string, stmt *ast.CreateTableStmt) *domain.Table <span class="cov8" title="1">{
        columns := make(map[string]*domain.Column)

        for _, c := range stmt.Cols </span><span class="cov8" title="1">{
                columns[c.Name.Name.O] = x.parseColumn(c)
        }</span>
        <span class="cov8" title="1">return &amp;domain.Table{
                Name:    tableName,
                Columns: columns,
        }</span>
}

func (x *extractor) parseView(stmt *ast.CreateViewStmt) *domain.View <span class="cov8" title="1">{
        // TODO
        return &amp;domain.View{
                SQL: "",
        }
}</span>

func (x *extractor) parseColumn(col *ast.ColumnDef) *domain.Column <span class="cov8" title="1">{
        dt := col.Tp.Tp
        parameters := make(map[string]interface{})

        if dt == mysql.TypeVarchar </span><span class="cov8" title="1">{
                parameters["size"] = col.Tp.Flen
        }</span>

        <span class="cov8" title="1">isNotNull := false
        for _, opt := range col.Options </span><span class="cov8" title="1">{
                if opt.Tp == ast.ColumnOptionNotNull </span><span class="cov0" title="0">{
                        isNotNull = true
                }</span>
        }

        <span class="cov8" title="1">return &amp;domain.Column{
                Datatype:   types.TypeStr(col.Tp.Tp),
                Parameters: parameters,
                IsNotNull:  isNotNull,
        }</span>
}

func (x *extractor) Leave(in ast.Node) (ast.Node, bool) <span class="cov8" title="1">{
        return in, true
}</span>

func (d *mySqlDriver) ParseMigration(scriptFile string) (*domain.Schema, error) <span class="cov8" title="1">{
        p := parser.New()
        stmtNodes, _, err := p.Parse(scriptFile, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">e := &amp;extractor{
                tables: make(map[string]*domain.Table),
                views:  make(map[string]*domain.View),
        }
        for _, n := range stmtNodes </span><span class="cov8" title="1">{
                n.Accept(e)
        }</span>
        <span class="cov8" title="1">return &amp;domain.Schema{
                Tables: e.tables,
                Views:  e.views,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package postgres

import (
        "fmt"
        "sort"

        "github.com/kenji-yamane/mgr8/domain"
)

type deparser struct { }

func inStringList(stringList []string, needle string) bool <span class="cov8" title="1">{
        isIn := false
        for _, s := range stringList </span><span class="cov8" title="1">{
                if needle == s </span><span class="cov8" title="1">{
                        isIn = true
                }</span>
        }
        <span class="cov8" title="1">return isIn</span>
}

func hasSingleArg(datatype string) bool <span class="cov8" title="1">{
        singleArgTypes := []string{"char", "varchar", "bit", "varbit", "time", "timestamp"}
        if inStringList(singleArgTypes, datatype) </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> {
                return false
        }</span>
}

func hasDoubleArg(datatype string) bool <span class="cov8" title="1">{
        doubleArgTypes := []string{"decimal", "numeric"}
        if inStringList(doubleArgTypes, datatype) </span><span class="cov8" title="1">{
                return true
        }</span>        else<span class="cov8" title="1"> {
                return false
        }</span>
}

func (d *deparser) CreateTable(table *domain.Table) string <span class="cov8" title="1">{
         statement := fmt.Sprintf("CREATE TABLE %s (\n", table.Name)

        columnKeys := []string{}
        for columnName, _ := range table.Columns </span><span class="cov8" title="1">{
                columnKeys = append(columnKeys, columnName)
        }</span>
        <span class="cov8" title="1">sort.Strings(columnKeys)

        for _, key := range columnKeys </span><span class="cov8" title="1">{
                column := table.Columns[key]

                statement = statement + fmt.Sprintf("%s %s", key, column.Datatype)

                if hasSingleArg(column.Datatype) </span><span class="cov8" title="1">{
                        statement = statement + fmt.Sprintf("(%d)", column.Parameters["size"])
                }</span> else<span class="cov8" title="1"> if hasDoubleArg(column.Datatype) </span><span class="cov8" title="1">{
                        statement = statement + fmt.Sprintf("(%d,%d)", column.Parameters["precision"], column.Parameters["scale"])
                }</span>

                <span class="cov8" title="1">if column.IsNotNull </span><span class="cov0" title="0">{
                        statement = statement + fmt.Sprintf(" NOT NULL")
                }</span>

                <span class="cov8" title="1">statement = statement + fmt.Sprintf(",\n")</span>
        }

        <span class="cov8" title="1">statement = statement[0:len(statement) - 2]
        statement = statement + fmt.Sprintf("\n)")
        return statement</span>
}

func (d *deparser) DropTable(tableName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("DROP TABLE IF EXISTS %s", tableName)
}</span>

func (d *deparser) AddColumn() string <span class="cov0" title="0">{
        // TODO
        return ""
}</span>

func (d *deparser) DropColumn(tableName, columnName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("ALTER TABLE %s DROP COLUMN %s", tableName, columnName)
}</span>
func (d *deparser) MakeColumnNotNull(tableName, columnName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("ALTER TABLE %s ALTER COLUMN %s SET NOT NULL", tableName, columnName)
}</span>

func (d *deparser) UnmakeColumnNotNull(tableName, columnName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("ALTER TABLE %s ALTER COLUMN %s DROP NOT NULL", tableName, columnName)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package postgres

import (
        "database/sql"
        "errors"
        "log"

        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq"
        pg_query "github.com/pganalyze/pg_query_go/v2"

        "fmt"

        "github.com/kenji-yamane/mgr8/domain"
)

type postgresDriver struct {
        tx *sql.Tx
}

func NewPostgresDriver() *postgresDriver <span class="cov8" title="1">{
        return &amp;postgresDriver{}
}</span>

func (d *postgresDriver) Deparser() domain.Deparser <span class="cov0" title="0">{
        return &amp;deparser{}
}</span>

func (d *postgresDriver) Execute(statements []string) error <span class="cov0" title="0">{
        for _, stmt := range statements </span><span class="cov0" title="0">{
                _, err := d.tx.Exec(stmt)
                if err != nil </span><span class="cov0" title="0">{
                        err2 := d.tx.Rollback()
                        if err2 != nil </span><span class="cov0" title="0">{
                                return err2
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (d *postgresDriver) ExecuteTransaction(url string, f func() error) error <span class="cov0" title="0">{
        db, err := sqlx.Connect("postgres", url)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>

        <span class="cov0" title="0">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">d.tx = tx

        err = f()
        if err != nil </span><span class="cov0" title="0">{
                err2 := d.tx.Rollback()
                if err2 != nil </span><span class="cov0" title="0">{
                        return err2
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return d.tx.Commit()</span>
}

func (d *postgresDriver) IsToolInstalled() (bool, error) <span class="cov0" title="0">{
        hasMigrationLogsTable, err := d.HasMigrationLogsTable()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">hasAppliedMigrationsTable, err := d.HasAppliedMigrationsTable()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if hasAppliedMigrationsTable != hasMigrationLogsTable </span><span class="cov0" title="0">{ // Has just one of them (XOR)
                return false, errors.New("database in dirty state, tool is partially installed")
        }</span>
        <span class="cov0" title="0">return hasAppliedMigrationsTable &amp;&amp; hasMigrationLogsTable, err</span>
}

func (d *postgresDriver) InstallTool() error <span class="cov0" title="0">{
        err := d.CreateMigrationsLogsTable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.CreateAppliedMigrationsTable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *postgresDriver) UninstallTool() error <span class="cov0" title="0">{
        err := d.DropMigrationsLogsTable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.DropAppliedMigrationsTable()
        return err</span>
}

func (d *postgresDriver) HasMigrationLogsTable() (bool, error) <span class="cov0" title="0">{
        var hasMigrationLogsTable bool
        err := d.tx.QueryRow(`SELECT EXISTS (
           SELECT FROM information_schema.tables
           WHERE  table_name   = $1
           )`, domain.LogsTableName).Scan(&amp;hasMigrationLogsTable)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return hasMigrationLogsTable, err</span>
}

func (d *postgresDriver) HasAppliedMigrationsTable() (bool, error) <span class="cov0" title="0">{
        var hasAppliedMigrationsTable bool
        err := d.tx.QueryRow(`SELECT EXISTS (
           SELECT FROM information_schema.tables
           WHERE  table_name   = $1
           )`, domain.AppliedTableName).Scan(&amp;hasAppliedMigrationsTable)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return hasAppliedMigrationsTable, err</span>
}

func (d *postgresDriver) CreateMigrationsLogsTable() error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`CREATE TABLE migration_log(
                migration_number INTEGER,
                type VARCHAR(4),
                username VARCHAR(32),
                date VARCHAR(32)
                )`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *postgresDriver) CreateAppliedMigrationsTable() error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`CREATE TABLE applied_migrations(
                version INTEGER,
                username VARCHAR(32),
                date VARCHAR(32),
                hash VARCHAR(32)
                )`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *postgresDriver) DropMigrationsLogsTable() error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`DROP TABLE migration_log`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *postgresDriver) DropAppliedMigrationsTable() error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`DROP TABLE applied_migrations`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (d *postgresDriver) InsertIntoMigrationLog(migrationNum int, migrationType string, username string, currentDate string) error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`INSERT INTO migration_log (
                migration_number,
                type,
                username,
                date
                ) VALUES ($1, $2, $3, $4)`, migrationNum, migrationType, username, currentDate)
        return err
}</span>

func (d *postgresDriver) InsertIntoAppliedMigrations(version int, username string, currentDate string, hash string) error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`INSERT INTO applied_migrations (
                version,
                username,
                date,
                hash
                ) VALUES ($1, $2, $3, $4)`, version, username, currentDate, hash)
        return err
}</span>

func (d *postgresDriver) RemoveAppliedMigration(version int) error <span class="cov0" title="0">{
        _, err := d.tx.Exec(`DELETE FROM applied_migrations WHERE version = $1`, version)
        return err
}</span>

func (d *postgresDriver) GetLatestMigrationVersion() (int, error) <span class="cov0" title="0">{
        var version int
        err := d.tx.QueryRow(`SELECT version FROM applied_migrations ORDER BY version DESC LIMIT 1`).Scan(&amp;version)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">return version, nil</span>
}

func (d *postgresDriver) GetVersionHashing(version int) (string, error) <span class="cov0" title="0">{
        var hash string
        err := d.tx.QueryRow(`SELECT hash FROM applied_migrations WHERE version = $1 LIMIT 1`, version).Scan(&amp;hash)
        if err != nil </span><span class="cov0" title="0">{
                return ``, err
        }</span>
        <span class="cov0" title="0">return hash, nil</span>
}

func (d *postgresDriver) ParseMigration(scriptFile string) (*domain.Schema, error) <span class="cov8" title="1">{
        result, err := pg_query.Parse(scriptFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tables := make(map[string]*domain.Table)
        views := make(map[string]*domain.View)
        for _, statement := range result.Stmts </span><span class="cov8" title="1">{
                switch statement.Stmt.Node.(type) </span>{
                case *pg_query.Node_CreateStmt:<span class="cov8" title="1">
                        parsedStatement := statement.Stmt.GetCreateStmt()
                        tableName := parsedStatement.Relation.Relname
                        tables[tableName] = d.parseTable(tableName, parsedStatement)</span>
                case *pg_query.Node_ViewStmt:<span class="cov8" title="1">
                        parsedStatement := statement.Stmt.GetViewStmt()
                        viewName := parsedStatement.View.Relname
                        views[viewName] = d.parseView(parsedStatement)</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("found an unsuported statement:\n %s", statement.Stmt.String())</span>
                }
        }

        <span class="cov8" title="1">return &amp;domain.Schema{
                Tables: tables,
                Views:  views,
        }, nil</span>
}

func (d *postgresDriver) parseTable(tableName string, parsedStatement *pg_query.CreateStmt) *domain.Table <span class="cov8" title="1">{
        columns := make(map[string]*domain.Column)
        for _, elts := range parsedStatement.TableElts </span><span class="cov8" title="1">{
                columnDefinition := elts.GetColumnDef()
                columns[columnDefinition.Colname] = d.parseColumn(columnDefinition)
        }</span>
        <span class="cov8" title="1">return &amp;domain.Table{
                Name:    tableName,
                Columns: columns,
        }</span>
}

func (d *postgresDriver) parseView(parsedStatement *pg_query.ViewStmt) *domain.View <span class="cov8" title="1">{
        // TODO
        return &amp;domain.View{
                SQL: "",
        }
}</span>

func (d *postgresDriver) parseColumn(columnDefinition *pg_query.ColumnDef) *domain.Column <span class="cov8" title="1">{
        datatype := columnDefinition.TypeName.Names[1].GetString_().GetStr()
        parameters := make(map[string]interface{})

        if datatype == "varchar" </span><span class="cov8" title="1">{
                parameters["size"] = columnDefinition.TypeName.Typmods[0].GetAConst().Val.GetInteger().Ival
        }</span>

        <span class="cov8" title="1">return &amp;domain.Column{
                Datatype:   datatype,
                Parameters: parameters,
                IsNotNull:  columnDefinition.IsNotNull,
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
